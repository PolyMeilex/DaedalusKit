use std::io::Write;

use byteorder::{LittleEndian, WriteBytesExt};
use dat_file::{
    properties::{DataType, ElemProps, PropFlag, Properties, SymbolCodeSpan},
    Symbol, SymbolData,
};
use zstring::{ByteVec, ZString};

use crate::{const_eval, symbol_indices::SymbolIndices};

#[derive(Debug)]
pub struct DatSymbolTable {
    symbols: Vec<Symbol>,
    generated_symbols_start: usize,
    autogenerated_symbols: Vec<Symbol>,
}

impl DatSymbolTable {
    pub fn new(symbol_indices: &SymbolIndices) -> Self {
        let mut this = Self {
            symbols: Vec::with_capacity(symbol_indices.len()),
            generated_symbols_start: symbol_indices.len(),
            autogenerated_symbols: Vec::new(),
        };

        this.push_symbol(Symbol {
            name: Some(ZString::from(b"\xFFINSTANCE_HELP")),
            props: Properties {
                off_cls_ret: 0,
                elem_props: {
                    let mut default = ElemProps::default();
                    default.set_count(1);
                    default.set_data_type(DataType::Instance);
                    default.set_flags(PropFlag::empty());
                    default.set_space(1);
                    default
                },
            },
            code_span: SymbolCodeSpan::empty(0),
            data: SymbolData::Address(0),
            parent: None,
        });

        this
    }

    /// "abc"
    pub fn string(&mut self, value: ZString) -> u32 {
        let symbol_id = 10000 + self.autogenerated_symbols.len();
        let mut symbol_str = format!("{symbol_id}").into_bytes();
        symbol_str.insert(0, 0xFF);

        let id = self.generated_symbols_start + self.autogenerated_symbols.len();
        self.autogenerated_symbols.push(Symbol {
            name: Some(ZString::from(symbol_str)),
            props: Properties {
                off_cls_ret: 0,
                elem_props: {
                    let mut default = ElemProps::default();
                    default.set_count(1);
                    default.set_data_type(DataType::String);
                    default.set_flags(PropFlag::CONST);
                    default.set_space(1);
                    default
                },
            },
            code_span: SymbolCodeSpan::empty(0),
            data: SymbolData::String(vec![value]),
            parent: None,
        });

        id as u32
    }

    /// extern func void name((var type PARN)*)
    pub fn extern_func(
        &mut self,
        name: ZString,
        span: SymbolCodeSpan,
        args: &[(ZString, DataType, SymbolCodeSpan)],
        ret: DataType,
        address: i32,
    ) -> u32 {
        let fn_symbol = self.push_symbol(Symbol {
            name: Some(name.clone()),
            props: Properties {
                off_cls_ret: ret as i32,
                elem_props: {
                    let mut default = ElemProps::default();
                    default.set_count(args.len() as u32);
                    default.set_data_type(DataType::Func);
                    let mut flags = PropFlag::CONST | PropFlag::EXTERNAL;
                    if ret != DataType::Void {
                        flags |= PropFlag::RETURN;
                    }
                    default.set_flags(flags);
                    default.set_space(1);
                    default
                },
            },
            code_span: span,
            data: SymbolData::Address(address),
            parent: None,
        });

        for (ident, arg, span) in args.iter() {
            let mut name = name.clone();
            name.0.push_char('.');
            name.0.push_str(ident);

            self.push_symbol(Symbol {
                name: Some(name),
                props: Properties {
                    off_cls_ret: 0,
                    elem_props: {
                        let mut default = ElemProps::default();
                        default.set_count(0);
                        default.set_data_type(*arg);
                        default.set_flags(PropFlag::empty());
                        default.set_space(1);
                        default
                    },
                },
                code_span: *span,
                data: match arg {
                    DataType::Float => SymbolData::Float(vec![]),
                    DataType::Int => SymbolData::Int(vec![]),
                    DataType::String => SymbolData::String(vec![]),
                    DataType::Class => SymbolData::ClassOffset(0),
                    DataType::Func => SymbolData::Address(0),
                    DataType::Prototype => SymbolData::Address(0),
                    DataType::Instance => SymbolData::Address(0),
                    DataType::Void => SymbolData::None,
                },
                parent: None,
            });
        }

        fn_symbol
    }

    /// func void name((var type PARN)*)
    pub fn func(
        &mut self,
        name: ZString,
        span: SymbolCodeSpan,
        args: &[(ZString, DataType, SymbolCodeSpan)],
        ret: DataType,
        address: u32,
    ) -> u32 {
        let fn_symbol = self.push_symbol(Symbol {
            name: Some(name.clone()),
            props: Properties {
                off_cls_ret: ret as i32,
                elem_props: {
                    let mut default = ElemProps::default();
                    default.set_count(args.len() as u32);
                    default.set_data_type(DataType::Func);
                    let mut flags = PropFlag::CONST;
                    if ret != DataType::Void {
                        flags |= PropFlag::RETURN;
                    }
                    default.set_flags(flags);
                    default.set_space(1);
                    default
                },
            },
            code_span: span,
            data: SymbolData::Address(address as i32),
            parent: None,
        });

        for (ident, arg, span) in args.iter() {
            let mut name = name.clone();
            name.0.push_char('.');
            name.0.push_str(ident);

            self.push_symbol(Symbol {
                name: Some(name),
                props: Properties {
                    off_cls_ret: 0,
                    elem_props: {
                        let mut default = ElemProps::default();
                        default.set_count(0);
                        default.set_data_type(*arg);
                        default.set_flags(PropFlag::empty());
                        default.set_space(1);
                        default
                    },
                },
                code_span: *span,
                data: match arg {
                    DataType::Float => SymbolData::Float(vec![]),
                    DataType::Int => SymbolData::Int(vec![]),
                    DataType::String => SymbolData::String(vec![]),
                    DataType::Class => SymbolData::ClassOffset(0),
                    DataType::Func => SymbolData::Address(0),
                    DataType::Prototype => SymbolData::Address(0),
                    DataType::Instance => SymbolData::Address(0),
                    DataType::Void => SymbolData::None,
                },
                parent: None,
            });
        }

        fn_symbol
    }

    pub fn class(
        &mut self,
        name: ZString,
        span: SymbolCodeSpan,
        fields: &[(ZString, DataType, u32, SymbolCodeSpan)],
        offset: i32,
        address: i32,
    ) -> u32 {
        let class_symbol = self.push_symbol(Symbol {
            name: Some(name.clone()),
            props: Properties {
                off_cls_ret: offset,
                elem_props: {
                    let mut default = ElemProps::default();
                    default.set_count(fields.len() as u32);
                    default.set_data_type(DataType::Class);
                    default.set_flags(PropFlag::empty());
                    default.set_space(1);
                    default
                },
            },
            code_span: span,
            data: SymbolData::Address(address),
            parent: None,
        });

        let mut address = address;
        for (ident, data_type, count, span) in fields.iter() {
            let mut name = name.clone();
            name.0.push_char('.');
            name.0.push_str(ident);

            self.push_symbol(Symbol {
                name: Some(name),
                props: Properties {
                    off_cls_ret: address,
                    elem_props: {
                        let mut default = ElemProps::default();
                        default.set_count(*count);

                        let size = match data_type {
                            DataType::Void => 0,
                            DataType::Float => 4,
                            DataType::Int => 4,
                            // class zSTRING { int allocater; char* vector; int length; int reserved; }
                            DataType::String => 20,
                            DataType::Class => todo!(),
                            DataType::Func => 4,
                            DataType::Prototype => todo!(),
                            DataType::Instance => todo!(),
                        };

                        address += *count as i32 * size;
                        default.set_data_type(*data_type);
                        default.set_flags(PropFlag::CLASS_VAR);
                        default.set_space(1);
                        default
                    },
                },
                code_span: *span,
                data: SymbolData::None,
                parent: Some(class_symbol),
            });
        }

        class_symbol
    }

    pub fn const_item(
        &mut self,
        name: ZString,
        code_span: SymbolCodeSpan,
        data: &const_eval::Value,
    ) -> u32 {
        self.push_symbol(Symbol {
            name: Some(name),
            props: Properties {
                off_cls_ret: 0,
                elem_props: {
                    let mut default = ElemProps::default();
                    default.set_count(1);
                    default.set_data_type(DataType::Int);
                    default.set_flags(PropFlag::CONST);
                    default.set_space(1);
                    default
                },
            },
            code_span,
            data: match data {
                const_eval::Value::Int(v) => SymbolData::Int(vec![*v]),
                const_eval::Value::Float(v) => SymbolData::Float(vec![*v]),
                const_eval::Value::String(_) => todo!(),
                const_eval::Value::Array(_) => todo!(),
                const_eval::Value::Symbol(_) => todo!(),
            },
            parent: None,
        })
    }

    pub fn instance(
        &mut self,
        name: ZString,
        code_span: SymbolCodeSpan,
        address: u32,
        parent: u32,
    ) -> u32 {
        self.push_symbol(Symbol {
            name: Some(name),
            props: Properties {
                off_cls_ret: 0,
                elem_props: {
                    let mut default = ElemProps::default();
                    default.set_count(0);
                    default.set_data_type(DataType::Instance);
                    default.set_flags(PropFlag::CONST);
                    default.set_space(1);
                    default
                },
            },
            code_span,
            data: SymbolData::Address(address as i32),
            parent: Some(parent),
        })
    }

    fn generate_sort_table(&self) -> Vec<u32> {
        let mut symbol_ids: Vec<_> = self
            .symbols
            .iter()
            .chain(self.autogenerated_symbols.iter())
            .enumerate()
            .map(|(i, s)| (i, &s.name))
            .collect();

        // Symbols map is sorted in alphabetical order
        symbol_ids.sort_by_key(|v| v.1.as_slice());
        symbol_ids.iter().map(|(id, _)| *id as u32).collect()
    }

    pub fn push_symbol(&mut self, symbol: Symbol) -> u32 {
        let id = self.symbols.len();
        self.symbols.push(symbol);
        id as u32
    }

    pub fn encode(&self, mut w: impl Write) {
        let sort_idx = self.generate_sort_table();

        w.write_u8(b'2').unwrap();
        w.write_u32::<LittleEndian>(
            self.symbols.len() as u32 + self.autogenerated_symbols.len() as u32,
        )
        .unwrap();

        for id in sort_idx.iter() {
            w.write_u32::<LittleEndian>(*id).unwrap();
        }

        for symbol in self.symbols.iter() {
            symbol.encode(&mut w).unwrap();
        }

        for symbol in self.autogenerated_symbols.iter() {
            symbol.encode(&mut w).unwrap();
        }
    }
}
